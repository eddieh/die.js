<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Die.js</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">
  <link href="assets/style.css" rel="stylesheet" />
</head>

<body>
  <h1>Die.js</h1>

  <blockquote id="die" class="pull-right">
    <p>
      Die (noun): a device for cutting or molding metal into a
      particular shape. an engraved device for stamping a design on
      coins or medals
    </p>

    <small>
      <cite title="">
        New Oxford American Dictionary 3rd edition &copy; 2010 by
        Oxford University Press, Inc.
      </cite>
    </small>
  </blockquote>

  <p>
    Die.js is a amalgamation
    of <a href="http://en.wikipedia.org/wiki/ERuby">eRuby</a> (ERB)
    and <a href="http://jinja.pocoo.org/">Jinja</a> templates. The
    implementation of the templating engine was originally derived
    from <a href="http://underscorejs.org/">Underscore.js</a>, but
    provides features from Jinja such as template inheritance, blocks,
    includes, and macros.
  </p>

  <h2>Introduction</h2>
  <p>
    Die compiles JavaScript templates into functions that can be
    evaluated for rendering. Templates are usefule for rendering
    complicated bits of HTML from JSON data sources. Template
    functions can interpolate variables, using <tt>&lt;%= &hellip;
    %&gt;</tt>, as well as execute arbitrary JavaScript code,
    with <tt>&lt;% &hellip; %&gt;</tt>. If you wish to interpolate a
    value, and have it be HTML-escaped, use <tt>&lt;%- &hellip;
    %&gt;</tt>
  </p>

  <p>
    Templates are compiled by calling Die's <tt>compile</tt>
    method. The first argument to <tt>compile</tt> is the template's
    source, the second argument is an optional name that can later be
    used to reference the compiled template. The method returns the
    compiled template as a JavaScript function that takes an object as
    an argument.
  </p>

  <p>
    When you evaluate a template function, pass in a <b>data</b>
    object that has properties corresponding to the template's free
    variables.
  </p>

<pre class="prettyprint linenums language-js">
var template = Die.compile("hello: &lt;%= name %&gt;");
template({name : 'moe'});
=&gt; "hello: moe"

var template = Die.compile("&lt;b&gt;&lt;%- value %&gt;&lt;/b&gt;");
template({value : '&lt;script&gt;'});
=&gt; "&lt;b&gt;&amp;lt;script&amp;gt;&lt;/b&gt;"</pre>


  <h2>Recognized Tags</h2>
  <p>
    Die.js recognizes the following template tags and converts them based
    on the rules below:
  </p>

<pre class="">
<% JavaScript statement -- inline with output %>
<%= JavaScript expression -- replace with result %>
<%- JavaScript expression -- replace with HTML-escaped result %>
<%# comment -- ignored %>
</pre>


  <h2>Template Functions</h2>
  <p>
    You can also use <tt>print</tt> from within JavaScript code.  This
    is sometimes more convenient than using <tt>&lt;%= &hellip;
    %&gt;</tt>.
  </p>

<pre class="prettyprint linenums language-js">
var template = Die.compile("&lt;% print('Hello ' + epithet); %&gt;");
template({epithet: "stooge"});
=&gt; "Hello stooge."</pre>

  <h2>Template Inheritance</h2>
  <p>
    Template inheritance allows you to build a base "skeleton"
    template that contains all the common elements for some set of
    templates. The base template defines <em>blocks</em> that child
    templates can override.
  </p>

<pre class="prettyprint linenums language-js">
Die.compile('&lt;% block("content") %&gt;&lt;% end("content") %&gt;', 'base');
var template = Die.compile('&lt;% extends("base") %&gt;' +
                           '&lt;% block("content") %&gt;Hello&lt;% end("content") %&gt;');
template();
=&gt; "Hello"</pre>

  <h3>Base Template</h3>
  <p>
    This template, which we'll call 'base.html', defines a simple HTML
    skeleton document that you might use for a simple two-column
    page. It's the job of "child" templates to fill the empty blocks
    with content:
  </p>

<pre class="prettyprint linenums language-html">
&lt;html&gt;
&lt;head&gt;
    &lt;% block("head") %&gt;
    &lt;link rel="stylesheet" href="style.css" /&gt;
    &lt;title&gt;
        &lt;% block("title") %&gt;&lt;% end("title") %&gt; - Site
    &lt;/title&gt;
    &lt;% end("head") %&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="content"&gt;
        &lt;% block("content") %&gt;&lt;% end("content") %&gt;
    &lt;/div&gt;
    &lt;div id="footer"&gt;
        &lt;% block("footer") %&gt;
        &amp;copy; Copyright 2008
        &lt;% end("footer") %&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

  <p>
    In this example, the <tt><% block("name") %></tt>
    and <tt><% end("name") %></tt> tags define four blocks that child
    templates can fill in. All the block tag does is to tell the
    template engine that a child template may override those portions
    of the template.
  </p>

  <h3>Child Template</h3>
  <p>
    A child template might look like this:
  </p>

<pre class="prettyprint linenums language-html">
&lt;% extends("base.html") %&gt;
&lt;% block("title") %&gt;Index&lt;% end("title") %&gt;
&lt;% block("head") %&gt;
    &lt;% super() %&gt;
    &lt;style type="text/css"&gt;
        .important { color: #336699; }
    &lt;/style&gt;
&lt;% end("head") %&gt;
&lt;% block("content") %&gt;
    &lt;h1&gt;Index&lt;/h1&gt;
    &lt;p class="important"&gt;
      Welcome on my awesome homepage.
    &lt;/p&gt;
&lt;% end("content") %&gt;
</pre>

  <p>
    The <tt><% extends("name") %></tt> tag is the key here. It tells
    the template engine that this template "extends" another
    template. When the template system evaluates this template, first
    it locates the parent. The extends tag should be the first tag in
    the template.
  </p>

  <h3>Extends</h3>
  <p>

  </p>

  <h3>Blocks</h3>
  <h3>Super</h3>

  <p>
    A child template does not need to override all blocks defined in
    the parent template. If a child doesn't define a block, the
    content of the parent block is used without the need for calling
    super.
  </p>

<pre class="prettyprint linenums language-js">
Die.compile('<% block("b1") %>One<% block("b1") %> ' +
            '<% block("b2") %><% block("b2") %>', 'base');
var template = Dice.compile('<% extends("base") %>' +
                            '<% block("b2") %>two<% block("b2") %>');
template();
=> "One two"
</pre>

  <h2>One-offs</h2>
  <p>
    If you're writing a one-off, you can pass
    the <b>data</b> object as the second parameter to <b>template</b>
    in order to render immediately instead of returning a template
    function.  The <b>settings</b> argument should be a hash
    containing any <tt>Die.settings</tt> that should be
    overridden.
  </p>

<pre class="prettyprint linenums language-js">
var list = "&lt;% Die.each(people, function(name) { %&gt; &lt;li&gt;&lt;%= name %&gt;&lt;/li&gt; &lt;% }); %&gt;";
Die.compile(list, {people : ['moe', 'curly', 'larry']});
=&gt; "&lt;li&gt;moe&lt;/li&gt;&lt;li&gt;curly&lt;/li&gt;&lt;li&gt;larry&lt;/li&gt;"
</pre>

  <h2>Variable Scope </h2>
  <p>
    By default, <b>template</b> places the values from your data
    in the local scope via the <tt>with</tt> statement.  However,
    you can specify a single variable name with
    the <b>variable</b> setting. This can significantly improve
    the speed at which a template is able to render.
  </p>

<pre class="prettyprint linenums language-js">
Die.compile("Using 'with': <%= data.answer %>", {answer: 'no'}, {variable: 'data'});
=&gt; "Using 'with': no"</pre>


  <h2>Precompilation</h2>
  <p>
    Precompiling your templates can be a big help when debugging
    errors you can't reproduce.  This is because precompiled
    templates can provide line numbers and a stack trace,
    something that is not possible when compiling templates on the
    client.  The <b>source</b> property is available on the
    compiled template function for easy precompilation.
  </p>

<pre class="prettyprint linenums language-js">&lt;script&gt;
  JST.project = <%= Die.compile(jstText).source %>;
&lt;/script&gt;</pre>


  <h2>Changing Delimiters</h2>
  <p>
    If eRuby-style delimiters aren't your cup of tea, you can change
    Die's template settings to use different symbols to set off
    interpolated code.  Define an <b>interpolate</b> regex to match
    expressions that should be interpolated verbatim, an <b>escape</b>
    regex to match expressions that should be inserted after being
    HTML escaped, and an <b>evaluate</b> regex to match expressions
    that should be evaluated without insertion into the resulting
    string. You may define or omit any combination of the three.  For
    example, to perform
    <a href="http://github.com/janl/mustache.js#readme">Mustache.js</a>
    style templating:
  </p>

<pre class="prettyprint linenums language-js">
Die.settings = {
  interpolate : /\{\{(.+?)\}\}/g
};

var template = Die.compile("Hello {{ name }}!");
template({name : "Mustache"});
=&gt; "Hello Mustache!"</pre>

  <h2>API</h2>
  This section describes all the public methods Die exposes.
  <dl class="method">
    <dt>Die.compile(templateString, [name], [settings])</dt>
    <dd></dd>
  </dl>

  <dl class="method">
    <dt>Die.template(name)</dt>
    <dd></dd>
  </dl>

<script src="vendor/google-code-prettify/prettify.js"></script>
<script>
  // make code pretty
  window.prettyPrint && prettyPrint()
</script>

</body>
</html>
